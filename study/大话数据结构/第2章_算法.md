## 2.1 算法的基本概念

什么是算法
- 是对特定问题的求解步骤
- 在计算机里面就针对某个问题的一段代码

高斯的故事

求1到100的累加和
```
const arr = [1, 2, 3, ... 100];
// 常规思路
// 会循环100次,如果arr是1亿,就得循环1亿次
arr.reduce((acu, cur) => acu + cur, 0);

// 高斯思路
// 无论数据量有多大,都只执行这一行代码
(arr[0] + arr[arr.length]) * 100 / 2
```

### 2.1.1 算法的4个特性

~~正确性~~
- ~~木有语法错误~~
- ~~正确的输入有预期的输出~~
- ~~错误的输入也要有预期的输出~~
- ~~刁难的输入也要能够处理~~
可读性
- ...这木有啥好说的吧
健壮性
- 这感觉和健壮性差不多
可行性
- 同上

### 2.1.2 设计算法的5个要求

输入输出
- 要有0或多个输入
- 必须要有输出
有穷
- 
时间快空间少
- 解决同一个问题
- 尽量少的时间
- 尽量少的空间

> 额,感觉这些特性,要求啊之类的完全是在死记硬背概念....完全记错位了...或许是因为对这个东西还是太生疏的原因,无法细致的区分这些特性之间的差别.所以在做笔记的时候,感觉特性和要求是一样的东西.

## 2.2 算法性能的评估方法

影响高级语言算法性能的4个要素
- 算法本身的逻辑
- 编译后代码的质量
- 机器执行指令的速度
- 算法要处理的问题的规模

### 2.2.1 事后统计法

什么是事后统计法
- 编写特定的测试代码,用于测试指定代码的性能.

事后统计法存在的问题
- 测试设备的性能会影响到测试结果
- 需要单独编写测试代码,成本非常大

### 2.2.2 事前分析法

什么是事前分析法
- 抛开编译和设备性能的影响因素
- 只考虑问题规模和算法本身的逻辑
- 纯理论的形式分析这两个要素的方法

事前分析法的好处
- 可以避开事后统计的缺点
- 能够以一种比较快速直观的方式统计算法性能

## 2.3 时间复杂度

什么是函数的渐进增长
- 给一定函数f(n)
- 随着输入n的增加
- 函数f的代码运行次数的增加速度,就是函数渐进增长

什么是时间复杂度
- 算法的总体代码运行次数
- 和函数渐近增长之间的关系
- 就叫函数渐进增长时间复杂度
- 简称时间复杂度

如何分析时间复杂度
- 统计代码行执行次数的时间
- 去掉常量 O(1 + 5 + 6 + n) -> O(n)
- 去掉系数 O(1 + 2n + 3n) -> O(n)
- 去掉低阶 O(1 + n^2 + n^3) -> O(n^3)

常见的时间复杂度,由快到慢

|大O表示法|释义|备注|
|:-:|:-:|:-:|
|O(1)|常量阶||
|O(n)|线性阶||
|O(logn)|对数阶||
|O(n*logn)n*对数阶||
|O(n^2)|平方阶||
|O(n^3)|立方阶||
|O(2^n)|(指数阶)|暂不考虑|
|O(n!)|阶乘阶|暂不考虑|
|O(n^n)|~~指数阶~~|暂不考虑|

## 2.4 空间复杂度

什么是空间复杂度
- 在执行代码时
- 所需要的数据本身的空间外
- 额外需要的空间数量
