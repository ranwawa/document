## 学习背景

本来是想跳过这一章的,因为对`var`和`let`实在是太熟悉了,但还是想看看有木有啥新奇的东西.果然,我所以为的熟悉,只不过是表面上的.看完这一章,认识又提升了一个高度

## var

```javascript
for (var i = 0; i < 10; i++) {
    setTimeout(function() { console.log(i); }, 100 * i);
}
```

为什么最后输出的是10
- 因为var会提升到顶级作用域
- 最后执行函数的时候,获取到的i,就是顶级作用域上的i
- 这个时候它的值是10,所以全部输出的是10

如何解决这个问题,让其输出0...9
- 使用闭包
- 使用let

闭包解决的原理
- var是函数作用域
- 立即执行函数/闭包会接收一个参数
- 在函数体内形成自己的作用域
- 函数执行时就把具体的值传进去了
- 所以当宏任务执行时,就是取的函数体内的值
- 闭包内的值就是传进去的那个值

let解决的原理
- let是块级作用域
- 每次一循环时,都创建了一个新的作用域
- i在当前作用域里生效
- 宏任务执行时,就是取的之前声明的作用域里的值
- 而那个值,就是每一次迭代的值

```javascript
for (var i = 0; i < 10; i++) {
    (function(i) {
      setTimeout(function() { console.log(i); }, 100 * i);
    })(i);
}
```

```javascript
for (let i = 0; i < 10; i++) {
    setTimeout(function() { console.log(i); }, 100 * i);
}
```


## let

下面的代码第4行为什么要报错
- let是块级作用域
- 在声明之前不可以操作
- 其原理是
  - 在声明它的语句之前的区域都属于暂时性死区
  - 暂时性死区无法对其读或写

下面的代码第2行为什么不报错
- 既然是之前不能读写,那为什么不报错呢?
- 因为foo函数声明时,并木有去执行函数体里面的代码
- 所以就不存在操作let变量了

```javascript
function foo() {
    return a;
}
foo();
let a;
```
