表达式expression是一个短语,JavaScript解释器会将其计算evaluate出一个结果.运算符operator将简单表达式组合成复杂表达式

## 4.1 原始表达式 primary expression 
原始表达式 = 常量+直接量+关键字+变量

## 4.2 对象和数组表达式
这个应该划分到直接量里面去的嘛?为什么在这里单独成一节
 - 数组[]
 - 对象{}
> 书上不是说的清清楚楚么,对象和数组表达式里面还可以包含其他表达式,而原始表达式是原子,最小的单元,肯定不能放在原始表达式里面嘛.你当时是咋在看书的啊?哈哈哈191106

## 4.3 函数定义表达式

function xx(x){...}

## 4.4 属性访问表达式
- expression.indetifier
- expression[expression]

- .和[之前的expression总会先计算
- 如果是null或undefined就异常
- 如果不是对象,则转换成对象

## 4.5 调用表达式

函数表达式()

## 4.6 对象创建表达式

new Object()
如果没有参数,括号可以省略

## 4.7 运算符概述

运算符优先级列表 书66页

### 4.7.1 操作数的个数
- 2元运算符 2个
- 1元运算符 1个
- 3元运算符 3个

### 4.7.2 操作数类型和结果类型
不同的运算符会对操作数的类型进行转换

### 4.7.3 左值lvalue

### 4.7.4 运算符的副作用
运算符会对后面的语句造成影响的就是叫有副作用的
- =
- ++
- \- -
- delete

### 4.7.5 运算符优先级
- =号最低
- 属性访问表达式和函数调用表达式最高
- 利用括号加强

### 4.7.6 运算符的结合
- 从左到右开始计算
- 从右到左开始计算
	- 1元运算符
	- 3元运算符
	- 赋值运算符

### 4.7.7 计算顺序
- 表达式中子表达式的计算顺序始终是从左到右
- 子表达式如果有副作用,会有点小不一样
```javascript
var a = 1;
b = (a++)+a; //=>3 先计算b 再计算a 再计算a 因为++有副作用所以第二次计算的是a++ 第一个a是1 第2个a是2
```

## 4.8 算术表达式

\* / - % 不作详细介绍,比较简单

### 4.8.1 + 运算符
- 如果其中一个数是对象,则会将其转换成原始值
- 转换成原始值后,如果是字符串,则将另外一个也转换成字符串

```javascript
1+2 //=>3
'1'+2 //=>'12'
1+{} //=>'1{object object}'
true+true //=> 2
2+null //=> 2
2+undefined //=> NaN
```

### 4.8.2 一元运算符
- +:转换成数字或NaN
- -:转换数字并取反
- ++:自增
- --:自减

### 4.8.3 位运算符
二进制表示 书72页

## 4.9 关系表达式

测试两个值之间的关系,并且返回true或false

### 4.9.1 相等和不相等运算符
- ==
- ===
	- 如果两个值都是null,undefined,NaN,也会不相等
- !=
- !==

### 4.9.2 比较运算符
还是会将操作数转换成数字和字符串再进行比较有意思么
- <
- >
- <=
- >=
- localCompare
	- 客串比较就用这个

### 4.9.3 in运算符

左侧的字符串 是否是 右侧对象的 属性名
```javascript
var point = {x:1,y:2};
'x' in point //=>true
'z' in point //=>false
3 in point //=>false
```

### 4.9.4 instancof 运算符

左侧的对象  是否是 右侧类的 实例
```javascript
var d = new Date();
d instanceof Date; //=>true
d instranceof Object //=>true
d instranceof Number //=>false
```

## 10 逻辑表达式

- &&
- ||
- !

### 10.1 逻辑与 &&
- 两者为真即真,只要有一个为假即为假
- 左侧为真则计算右侧表达式
**短路行为short circuiting**
```javascript
if(a===b) stop();
(a===b)&& stop(); //两个代码的效果一模一样
```

### 10.2 逻辑或 ||
- 有一个为真即为真
- 左侧为真则只计算左侧
```javascript
var max = m||{};  //如果m没有定义,就自动创建一个对象
```

### 10.3 逻辑非 !
先将操作数转换成布尔值,再取反
```javascript
!(p&& q) === !p || !q;
!(p || q) === !p && !q; //无论p,q取什么值,都恒成立
```

## 11 赋值表达式

优先级最低
- =
- +=
- -=
- *=
- /=
- %=

正常情况下是如下的转换:
a op = b;
a = a op b;

**如果左侧包含有副作用的表达式,则不成立**
```javascript
a[i++] +=2;
a[i++] = a[i++]+2; //这两个就不相等
```

## 12 表达式计算 eval

不推荐使用 书83页

### 12.1 eval()

### 12.2 全局eval()

### 12.3 严格eval()

## 13 其他运算符

### 13.1 条件运算符
?:
先计算最右边

### 13.2 typeof运算符

| X|     typeof x|
| :-------- | --------:|
| undefined    |   'undefined'| 
| null|'null'|
|true/false|'object'
|数字/NaN|'number'
|字符串|'string'
|函数|'function'
|内置对象|'object'

**注意**
- 如何区分 null 和 object
- 如果区分 array 和object

### 13.3 delete 运算符
- 删除数组 只是清空值
- 删除属性 完全删除掉属性

不能删除的属性
- 内置核心属性
- 客户端属性
- var声明的属性
- function定义的函数

### 13.4 void运算符

执行void 右边的表达式 ,但是忽略计算结果

这就是在链接中代替#的原理所在

### 13.5 逗号运算符
书上讲的没明白,就是分隔两个表达式,怎么又要返回右侧的计算结果

> 就是多个不同的表达式放在一行,用逗号隔开,只返回最后一个表达式的结果.