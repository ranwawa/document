## 13.1 客户端JavaScript

Window对象是客户端JavaScript**特性**和**API**的主要接入点

**为什么不加window也可以调用全局变量**
- Window对象是客户端JS的作用域顶部
- 有一个window属性是指向自身
- 其他全局变量或方法,是直属于Window下面的属性
- 自定义的全局变量,也是挂载Window下面的全局变量

### 13.1.1 Web文档里的JavaScript
**DHTML**内容样式行为的组合就叫动态HTML
**重要原则:**
- 用户的体验不依赖于JavaScript,JavaScript只是用来增强体验的.
- 可以没有JavaScript
- 它在页面呈现上只是锦上添花的作用

### 13.1.2 Web应用中的JavaScript
**一个清晰的认识:**
- 现代浏览器已经是一个简单的操作系统了

**在文档和应用中的根本区别:**
- 设计良好的文档,在禁用JavaScript后还能继续工作
- web应用本质上就是JavaScript程序

## 13.2 在HTML里嵌入JavaScript

**嵌入客户端JavaSscript的4种方法:**
- 内联
- 外部引用
- HTML事件处理程序
- URL使用javascript协议

### 13.2.1 <script\>元素
**在XHTML下的注意事项:**
- 在XHTML中,script标签里面的<和&会解释成XML标记
- 所以script中的代码应该放进CDATA里面
```htmlbars
<script>
<![CDATA[
 //....   
]]
</script>
```
### 13.2.2 外部文件中的脚本
**属性的2点注意:**
- 默认type是text/javascript,所以可以不用写
- 如果指定一个无法解释的type,则不会解释元素体内的内容,也不会下载src的文件

**元素体的2点注意:**
- 元素体内不能旋转任何文本,否则会报错
- 可以用空格或注释来进行描述

**使用src的4个优点:**
- 简洁,行为分离
- 复用,模块化开发
- 省流,多页面自动缓存
- 接口,引入广告或插件
- 标准,google标准类库cdn的运用

**另类应用:**
- 通过不可识别的type+元素体内不被解释的文本,可以开发数据嵌入技术,如:ControlJS

### 12.2.3 HTML中的事件处理程序
不利于内容和行为的分离,不使用

### 13.2.4 URL中的JavaScript
- 在URL后面跟一个javascript:
- 语句用分号隔开
- 注释只能是/**/
- 识别结果是转换成字符串的返回值
- 然后替换整个文档
- 返回undefined不会进行替换

**另类用法:bookmarklet**
- 把整个链接搞成一段js代码
- 然后保存为一个书签
- 可以在所有页面上运行这个书签做一些小动作.比较检查当前页面的字数等
```htmlbars
<a href="javascript:
    var e = '',r='';
        do{
            e = prompt('expression:'+e+'\n'+r+'\n');
                try{
                    r='Result:'+document.body.innerHTML;
                }catch (ex){
                    r = ex;
                }
        }while(e);
            void 0;        
">javascript evaluator</a>
```
## 13.3 JavaScript程序的执行

### 13.3.1 同步,异步和延迟的脚本
**同步:**
- 当HTML解析器遇到<script\>元素时,默认必须先执行脚本,如果是远程的就要先下载下来再执行.这个时候就会停止渲染和解析后面的文档
- 可以使用write在当前位置插入文档内容

**异步:**
- 添加script的async属性
- 不阻止渲染,下载完成后立即执行

**延迟:**
- 添加script的defer属性
- 告诉浏览器,直到文档载入和解释完成后才执行脚本

**异步和延迟的异同:**
- 都会告诉浏览器,脚本不会使用write
- defer按出现顺序执行,async下载完后立即执行

### 13.3.2 事件驱动的JavaScript
事件 = 事件类型+目标+事件处理程序

**注册多个事件监听器**

**微软的兼容处理**

**冒泡**

### 13.3.3 客户端JavaScript线程模型
单线程
为什么要使用单线程

### 13.3.4 客户端JavaScript时间线
1. 创建Document对象
  - 解析HTML元素和文本内容 => 将解析内容添加至Element对象和Text节点到文档中
  - document.readystate === loding 
2. 遇到脚本时
  - 下载或执行脚本(此时脚本可以看到自己和他之前的文档内容)
  - 暂停解析内容
3. 遇到sync脚本时
  - 开始下载脚本
  - 但继续解析后面的元素和内容
4. 文档完成解析
  - document.readyState === interactive 
5. 按顺序执行defer脚本
6. 文档完全解析完成 
  - 触发Document的DOMContentLoaded事件
  - 可能图片还在继续载入
  - 同步脚本执行阶段转到异步事件驱动阶段
7. 图片载入完成,异步事件执行完成 ,
  - 触发Window对象的load事件
  - document.readyState === complete
8. 可以调用异步事件

## 13.4 兼容性和可用性

**3类兼容性和交互性问题:**
- **演化:**老浏览器没办法支持
- **未实现:**不同的产商实现不一样的特性
- **bug:**不同的浏览器都 有自己的bug

### 13.4.1 处理兼容性的类库
通过第三方类库来解决兼容性问题

### 13.4.2 分组浏览器支持
以雅虎为例,另一种处理兼容性的思路

### 13.4.3 功能测试
在脚本中判断当前浏览器是否支持某个功能

### 13.4.4 怪异模式
微软的以前的问题,现在不太重要了

### 13.4.5 浏览器测试
通过浏览器嗅探器定位当前是哪个浏览器和什么版本针对性的处理

### 13.4.6 ie里的条件注释
专门为IE搞的2种应对措施,只有IE的浏览器才会执行这些代码

```
<!--[if IE 6]><![endif]--]
```

## 13.5 可访问性

主要是针对视觉障碍,或者听力障碍的人
或者只使用固定外设的的一种交互问题
还有一个可访问性标准 书334页

## 13.6 安全性

### 13.6.1 JavaScript不能做什么
- 浏览器不支持某些功能,比如数据读写
- 在某些功能上加上限制
	- 不能乱弹新窗口
	- 不能关闭别人的标签
	- 不能修改file信息
	- 同源
	- 等等

### 13.6.2 同源策略
即脚本无法访问不同源的文档,即协议+主机+端口
**不严格的同源策略:**
- 在每个脚本里面设置相同的document.domain属性,不同的页面就可以互相访问了
- 跨域资源共享:即设置Access-Control-Allow-Origin响应头和Origin请求头
- 跨文档消息:即popstMessage在不同的页面间通信

### 13.6.3 脚本化插件和ActiveX控件

### 13.6.4 跨域脚本
通过提交HTML内容来篡改目标网站的内容

### 13.6.5 拒绝服务攻击
无限循环计算

## 13.7 客户端框架

- jQuery
- Prototype
- Dojo
- YUI
- Closure
- GWT