> 不得不说,犀牛书的正则比蝴蝶书讲的好,它这个是根据不同的分类进行描述的,一共就6个分类,每个分类下有几个关键字,从整体上把握了语法结构,学习起来就快很多了

- 正则表达式直接量
- RegExp构造函数

**注意:**
- 直接量的方式,每次运行的时候,都要创建一个新的对象

```javascript
function getRe() {
  var re = /[a-z]/;
  re.foo  = 'bar';
  return re;
}
var r1 = getRe(),r2 = getRe();
r1.foo = 'xx';
console.log(r1.foo, r2.foo); // => 
```
> 上面这个例子和正则有毛关系啊?

## 10.1 正则表达式的定义

### 直接量字符
按照字面意思进行匹配
- 字母
- 数字
- \o NUL字符
- \t 制表符
- \n 换行符
- \v 垂直制表符
- \f 换页符
- \r 回车符

需要转义的标点符号
- ^
- $
- .
- *
- +
- ?
- =
- !
- :
- \
- /
- ()
- []
- {}

### 字符类
[...]: 将直接量字符放在方括号里面就是字符类
- [...] 方括号内的任意字符
- [^...] 不包括方括号内的字符
- .  除换行符和其他Unicode行终止符以外的任意字符
- \w 等价于[a-zA-Z-0-9]
- \w 等价于[^a-zA-Z0-9]
- \s 任何Unicode空白符
- \S 等价于[^\s]
- \d 等价于[0-9]
- \D 等价于[^\d]
- \b 退格直接量

### 重复
表示某元素重复出现的次数
- {n,m} 匹配前一元素至少n次,最多m次
- {n,} 匹配前面一元素至少n次
- {n} 匹配前一项n次
- ? 0次或一次 等价于{0,1}
- \+ 1次或多次 等价于{1,}
- \* 0次或多次 等价于{0,}

非贪婪重复
- 在重复后面加上一个?即可  ??,+?,{n,}?

### 选择,分组和引用
| :
- /ab|cd|ef| 3选1
- 从左到右进行匹配,只有左边的没有了才匹配右边的

分组 ()
- 组合子表达式 /java(script)*/
- 定义子模式  可以从返回值中抽取括号中的内容 
- 引用子表达式 可以在后续正则中引用之前括号中的内容

只分组不引用(?:...)
- \n 第几个分组匹配的字符

注意:
- 不能在字符类中使用子表达式引用
- 分组的子表达式是从左到右以(为准计数的 /([jJ](?:[Ss]cript)?)\sis(fun\w*)/ 其中(fun\w* )是 \3第3个子表达式

### 指定匹配位置
称为正则表达式的锚,只是一个标记
- ^ 开头
- $ 结尾
- \b 单词边界
- (?=p) 先行断言 接下来的字符都与p匹配,但不包括p
- (?!p) 负向先行断言 接下来的字符不与p匹配

### 修饰符
放在/后面的
- i 不区分大小写
- g 执行一个全局匹配
- m 多行匹配模式

```javascript
console.log('abcdeffff'.match(/abc|ab|ef/)); // => 
console.log('abcdeffff'.match(/abc(def)*/),'abcdeffff'.match(/abcdef*/)); // =>
console.log('小王:"你好,我是\'大哥大\'!"'.match(/['"][^'"]*['"]/)); //~~ =>
console.log('小王:"你好,我是\'大哥大\'!"'.match(/(['"])[^"']*\1/)); // =>

var r = /[Jj]ava([Ss]cript)?(?=\:)/;
var s = 'JavaScript: The Definitive Guide';
var s2 = 'Java in a Nutshell';
console.log(s.match(r)); // =>
console.log(s2.match(r)); // =>

var r = /Java(?!Script)([A-Z]\w*)/;
var s = 'JavaBeans';
var s2 = 'Javanese';
var s3 = 'JavaScript';
var s4 = 'JavaScriper';
console.log(s.match(r)); // =>
console.log(s2.match(r)); // =>
console.log(s3.match(r)); // => null
console.log(s4.match(r)); // => JvaScripter
```
## 10.2 用于模式匹配的String方法

4种方法
- **search**
	- 参数是正则表达式
	- 返回第一个匹配的位置,没有则-1
	- **注意**
		- 不支持全局检索
		- 如果是字符串,则会自动转换成正则
- **replace**
	- 第1个参数是正则表达式或字符串
	- 第2个参数是要替换的内容
	- **注意:**
		- 可以在第2个参数中通过$加数字,引用正则中的子表达式
		- 第2个参数可以是函数
- **match**
	- 参数是正则表达式
	- 返回一个数组
		- **注意**
			- 参数如果是客串会转换成正则
			- 如果是全局检索,每个元素都是匹配到的子串
			- 如果不是全局检索,第1个元素是匹配到的子串,其他元素则存放$n子表达式的内容
- **split**
	- 用指定的正则拆分字符串为数组
	- **注意**
		- 字符串还是要转换成正则
## 10.3 RegExp对象

动态创建正则表达式的时候,就必须使用RegExp对象来创建了

**创建方法**
- new RegEx('','')
	- 第一个参数是正则字符串内容
	- 第二个参数是全局修饰符

**4个属性**
- source 正则的文本
- global 是否有g
- ignoreCase 是否有i
- multiline 是否有m
- lastIndex 下一次检索的起始位置 可以修改
	- 同一个正则第2次调用exec时,会从lastindex开始匹配
	- String的方法其实是简单的把lastindex置为0
**2个方法**
- exec
	- 返回一个数组
	- 类似于match的非全局匹配
- test() 和exec一样,只是返回的是布尔值
```javascript
var pattern = /Java/g;
var text = 'JavaScript is more fun tha Java!';
var result;
while((result = pattern.exec(text))!=null){
    console.log(result); // =>
    console.log(pattern.test(text)); // =>
}
```
## 常见正则
#### 中文姓名
```
/^[\u4e00-\u9fa5]+(·[\u4e00-\u9fa5]+)*$/
```
#### 手机号码
```
  /^(13|14|15|18|17)\d{9,9}/
```
#### 银行卡
```
/^[1-9]\d{12, 18}/
```
#### 身份证
```
( ^[1-9]\d{5}(18|19|([23]\d))\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$)|(^[1-9]\d{5}\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{2}$)
```