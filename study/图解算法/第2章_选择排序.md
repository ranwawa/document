## 2.1 内存的工作原理

内存长什么样
- 类似于超市储物柜的二维格子空间

存储数据的2种基本方式
- 数组
- 链表

存储数据的过程
- 请求存储空间
- 分配存储地址

## 2.2 数组和链表

数组的特点
- 从头到尾都是连续的一块内存空间

数组的缺点
- 为避免数组超容,一般会多申请一点空间
  - 容易导致内存浪费
- 为了始终保持内存连续,超容会扩容迁移
  - 迁移的过程非常耗时

链表的特点
- 数据的元素,可以分配到内存的任意位置

链表的缺点
- 每个元素都会带上其他元素的内存地址
  - 非常浪费空间

数组和链表各种操作的时间复杂度

||查找|插入|删除|
|:-:|:-:|:-:|
|数组|O(1)|O(n)|O(n)|
|链表|O(n)|O(1)|O(1)|

数组的适用场景
- 适用于频繁查找的场景

链表的适用场景
- 适用于步骤插入删除的场景

## 2.3 选择排序

什么是选择排序
- 取出数据中的一个元素
- 依次和其他所有元素对比
- 将最大/小的放在最前面
- 然后取第2个,依次循环

选择排序和冒泡排序的区别
- 选择排序,在一次循环中,对比守所有数据后移动,只移动一次数据
- 冒泡排序,在一次循环中,每对比一次就移动一次

自己实现一个选择排序

```javascript
var arr = [
  {name: '专家web', value: 8823432,},
  {name: '中级web', value: 38632},
  {name: '初级web', value: 28000},
  {name: '资深web', value: 123442},
  {name: '高级web', value: 86332},
  {name: '全干专家', value: 888888888},
];
var length = arr.length;
var minIndex;
var minValue;
for (var i = 0; i < length; i++) {
  var temp = arr[i];
  minIndex = i;
  minValue = temp.value;
  for (var j = i+1; j < length; j++) {
    if (minValue < arr[j].value) {
      minIndex = j;
      minValue = arr[j].value;
    }
  }
  if (i !== minIndex) {
    arr[i] = arr[minIndex];
    arr[minIndex] = temp;
  }
}
```

为什么选择排序的时间复杂度是O(n^2)
- 第一次循环对比n次
- 第2次循环对比n-1次...直到最后一次循环对比2次
- 其原理就和高斯故事一样,使用的是倒序相加法
